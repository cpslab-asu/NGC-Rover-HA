from __future__ import annotations

import logging

import click
import staliro
import staliro.optimizers
import staliro.specifications.rtamt

import simulation
from controller.attacks import FixedSpeed


@click.group()
@click.option("-v", "--verbose", is_flag=True)
@click.pass_context
def test(ctx: click.Context, verbose: bool):
    if verbose:
        logging.basicConfig(level=logging.INFO)

    ctx.ensure_object(dict)
    ctx.obj["verbose"] = verbose


@test.command()
@click.pass_context
def cpv1(ctx: click.Context):
    @staliro.models.model()
    def model(sample: staliro.Sample) -> staliro.Trace[dict[str, float]]:
        result = simulation.run(
            frequency=1,
            magnet=None,
            speed=FixedSpeed(sample.static["speed"]),
            verbose=ctx.obj["verbose"]
        )
        trace = {
            step.time: {
                "x": step.position[0],
                "y": step.position[1],
                "z": step.position[2],
                "theta": step.heading,
                "omega": step.roll,
            }
            for step in result.history
        }

        return staliro.Trace(trace)

    spec = staliro.specifications.rtamt.parse_dense("always (x >= 0)")  # Use reference trajectory to assert error never exceeds given bound
    opt = staliro.optimizers.UniformRandom() # TODO: replace with SOAR
    opts = staliro.TestOptions(
        runs=1,
        iterations=100,
        static_inputs={
            "speed": (0, 100),
        },
        signals={},
    )
    runs = staliro.test(model, spec, opt, opts)
    run = runs[0]  # We know there is only a single run, so just extract it
    eval = run.evaluations[0]  # Extract the first sample generated by the optimizer


@test.command()
def cpv2():
    pass


@test.command()
def cpv3():
    pass


if __name__ == "__main__":
    test()
